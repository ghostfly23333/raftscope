<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Raft 自动化测试</title>
    <link rel="stylesheet" href="bootstrap-3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="bootstrap-slider/css/bootstrap-slider.css">
    <link rel="stylesheet" href="style.css">
    <style>
        @font-face {
            font-family: 'Glyphicons Halflings';
            src: url('bootstrap-3.1.1/fonts/glyphicons-halflings-regular.eot');
            src: url('bootstrap-3.1.1/fonts/glyphicons-halflings-regular.eot?#iefix') format('embedded-opentype'),
                 url('bootstrap-3.1.1/fonts/glyphicons-halflings-regular.woff') format('woff'),
                 url('bootstrap-3.1.1/fonts/glyphicons-halflings-regular.ttf') format('truetype'),
                 url('bootstrap-3.1.1/fonts/glyphicons-halflings-regular.svg#glyphicons-halflingsregular') format('svg');
        }
        .test-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: white;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            z-index: 1000;
        }
        .test-log {
            height: 200px;
            overflow-y: auto;
            background: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .test-button {
            margin: 5px;
            width: 100%;
        }
        .success {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        .info {
            color: #17a2b8;
        }
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        .server {
            cursor: pointer;
        }
        .server .term {
            fill: white;
            font-size: 10px;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        .server circle.background {
            fill: #66c2a5;
            stroke: #666;
            stroke-width: 3;
        }
        .server.leader circle.background {
            stroke: #666;
            stroke-width: 5;
        }
        .server.follower circle.background {
            fill: #666;
        }
        .server.candidate circle.background {
            fill: #fc8d62;
        }
        .server text.serverid {
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 14px;
            font-weight: bold;
            fill: #333;
        }
        .message {
            fill: #fc8d62;
            stroke: #666;
            stroke-width: 2;
        }
        .message.reply {
            fill: #66c2a5;
        }
    </style>
</head>
<body>
    <!-- 原始项目的SVG容器 -->
    <svg id="canvas" width="800" height="600">
        <defs>
            <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="gray" stroke-width="0.5"/>
            </pattern>
            <marker id="TriangleOutM" orient="auto" refX="0" refY="0" style="overflow:visible">
                <path d="M 0,0 L 10,5 L 0,10 z" fill="black"/>
            </marker>
        </defs>
        <g id="root">
            <rect width="100%" height="100%" fill="url(#grid)" />
            <g id="ring">
                <circle cx="400" cy="300" r="200" stroke="#aaa" stroke-width="1" fill="none"/>
            </g>
            <g id="messages"></g>
            <g id="servers"></g>
            <g id="logs"></g>
        </g>
    </svg>

    <!-- 测试控制面板 -->
    <div class="test-panel">
        <h4>Raft 自动化测试场景</h4>
        <div class="btn-group-vertical" style="width: 100%">
            <button id="run-all-tests" class="btn btn-primary test-button">运行所有测试</button>
            <button id="test-leader-election" class="btn btn-info test-button">测试Leader选举</button>
            <button id="test-leader-crash" class="btn btn-danger test-button">测试Leader崩溃</button>
            <button id="test-log-replication" class="btn btn-success test-button">测试日志复制</button>
            <button id="test-network-partition" class="btn btn-warning test-button">测试网络分区</button>
        </div>
        <div class="test-log" id="test-log"></div>
    </div>

    <script src="jquery/jquery.min.js"></script>
    <script src="bootstrap-3.1.1/js/bootstrap.min.js"></script>
    <script src="bootstrap-slider/js/bootstrap-slider.js"></script>
    <script src="bootstrap-contextmenu/bootstrap-contextmenu.js"></script>
    <script src="util.js"></script>
    <script src="raft.js"></script>
    <script src="state.js"></script>
    <script src="script.js"></script>
    <script>
        $(function() {
            // SVG 辅助函数
            function SVG(tag) {
                return $(document.createElementNS('http://www.w3.org/2000/svg', tag));
            }

            // 渲染器
            var render = {
                update: function() {
                    this.servers();
                    this.messages();
                },
                servers: function() {
                    var svg = $('#canvas');
                    var ringSpec = {
                        cx: 400,
                        cy: 300,
                        r: 200
                    };

                    // 清除现有服务器
                    $('#servers').empty();

                    // 绘制服务器
                    state.current.servers.forEach(function(server) {
                        var angle = (server.id - 1) / NUM_SERVERS * 2 * Math.PI;
                        var x = ringSpec.cx + ringSpec.r * Math.cos(angle);
                        var y = ringSpec.cy + ringSpec.r * Math.sin(angle);

                        var serverGroup = SVG('g')
                            .attr('id', 'server-' + server.id)
                            .attr('class', 'server ' + server.state);

                        // 服务器背景圆圈
                        serverGroup.append(SVG('circle')
                            .attr('class', 'background')
                            .attr({
                                cx: x,
                                cy: y,
                                r: 30
                            }));

                        // 服务器ID
                        serverGroup.append(SVG('text')
                            .attr('class', 'serverid')
                            .attr({
                                x: x,
                                y: y - 45
                            })
                            .text('S' + server.id));

                        // 任期号
                        serverGroup.append(SVG('text')
                            .attr('class', 'term')
                            .attr({
                                x: x,
                                y: y
                            })
                            .text(server.term));

                        $('#servers').append(serverGroup);
                    });
                },
                messages: function() {
                    var svg = $('#canvas');
                    $('#messages').empty();

                    state.current.messages.forEach(function(msg) {
                        var progress = (state.current.time - msg.sendTime) /
                            (msg.recvTime - msg.sendTime);
                        
                        if (progress >= 0 && progress <= 1) {
                            var fromServer = state.current.servers.find(s => s.id === msg.from);
                            var toServer = state.current.servers.find(s => s.id === msg.to);
                            
                            if (fromServer && toServer) {
                                var fromAngle = (fromServer.id - 1) / NUM_SERVERS * 2 * Math.PI;
                                var toAngle = (toServer.id - 1) / NUM_SERVERS * 2 * Math.PI;
                                
                                var fromX = 400 + 200 * Math.cos(fromAngle);
                                var fromY = 300 + 200 * Math.sin(fromAngle);
                                var toX = 400 + 200 * Math.cos(toAngle);
                                var toY = 300 + 200 * Math.sin(toAngle);
                                
                                var x = fromX + (toX - fromX) * progress;
                                var y = fromY + (toY - fromY) * progress;
                                
                                $('#messages').append(
                                    SVG('circle')
                                        .attr('class', 'message ' + msg.direction)
                                        .attr({
                                            cx: x,
                                            cy: y,
                                            r: 8
                                        })
                                );
                            }
                        }
                    });
                }
            };

            // 测试日志函数
            function log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const div = $('<div>')
                    .addClass(type)
                    .text(`${timestamp}: ${message}`);
                $('#test-log').prepend(div);
            }

            // 等待函数
            function wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // 初始化状态和时间驱动
            function initState() {
                state = makeState({
                    servers: [],
                    messages: [],
                });

                // 设置状态更新器
                state.updater = function(s) {
                    var changes = false;
                    s.current.messages = s.current.messages.filter(function(message) {
                        if (message.recvTime <= s.current.time) {
                            raft.handleMessage(s.current, message);
                            changes = true;
                            return false;
                        } else {
                            return true;
                        }
                    });
                    s.current.servers.forEach(function(server) {
                        if (server.electionAlarm <= s.current.time) {
                            raft.rules.startNewElection(s.current, server);
                            s.current.servers.forEach(function(peer) {
                                if (peer !== server) {
                                    raft.rules.sendRequestVote(s.current, server, peer.id);
                                }
                            });
                            changes = true;
                        }
                        if (server.state === 'leader') {
                            s.current.servers.forEach(function(peer) {
                                if (peer !== server) {
                                    raft.rules.sendAppendEntries(s.current, server, peer.id);
                                }
                            });
                        }
                        raft.rules.becomeLeader(s.current, server);
                    });
                    return changes;
                };

                // 初始化服务器
                for (var i = 1; i <= NUM_SERVERS; i += 1) {
                    var peers = [];
                    for (var j = 1; j <= NUM_SERVERS; j += 1) {
                        if (i != j)
                            peers.push(j);
                    }
                    state.current.servers.push(raft.server(i, peers));
                }

                state.init();
                render.update();
            }

            // 时间驱动函数
            let timeDriver;
            function startTimeDriver() {
                if (timeDriver) clearInterval(timeDriver);
                timeDriver = setInterval(() => {
                    state.seek(state.current.time + 1000);
                }, 50);
            }

            function stopTimeDriver() {
                if (timeDriver) {
                    clearInterval(timeDriver);
                    timeDriver = null;
                }
            }

            // 等待Leader选举完成
            async function waitForLeader(timeout = 5000) {
                const startTime = Date.now();
                while (Date.now() - startTime < timeout) {
                    const leader = state.current.servers.find(s => s.state === 'leader');
                    if (leader) return leader;
                    await wait(100);
                }
                return null;
            }

            // 测试场景1: Leader选举
            async function testLeaderElection() {
                log('开始测试: Leader选举', 'info');
                
                // 重置状态
                initState();
                startTimeDriver();
                
                // 等待选举完成
                const leader = await waitForLeader();
                if (leader) {
                    log(`选举成功: 服务器 ${leader.id} 成为Leader (Term ${leader.term})`, 'success');
                    return true;
                } else {
                    log('选举失败: 没有服务器成为Leader', 'error');
                    return false;
                }
            }

            // 测试场景2: Leader崩溃
            async function testLeaderCrash() {
                log('开始测试: Leader崩溃', 'info');
                
                // 等待初始Leader选举
                const initialLeader = await waitForLeader();
                if (!initialLeader) {
                    log('测试失败: 无法选出初始Leader', 'error');
                    return false;
                }
                
                log(`初始Leader: 服务器 ${initialLeader.id} (Term ${initialLeader.term})`, 'info');
                
                // 模拟Leader崩溃
                initialLeader.state = 'follower';
                initialLeader.votedFor = null;
                initialLeader.electionAlarm = state.current.time;
                
                // 等待新的Leader选举
                const newLeader = await waitForLeader();
                if (newLeader && newLeader.id !== initialLeader.id) {
                    log(`新的Leader选举成功: 服务器 ${newLeader.id} (Term ${newLeader.term})`, 'success');
                    return true;
                } else {
                    log('新的Leader选举失败', 'error');
                    return false;
                }
            }

            // 测试场景3: 日志复制
            async function testLogReplication() {
                log('开始测试: 日志复制', 'info');
                
                // 等待Leader选举
                const leader = await waitForLeader();
                if (!leader) {
                    log('测试失败: 无法选出Leader', 'error');
                    return false;
                }
                
                // 添加日志条目
                const logEntry = {
                    term: leader.term,
                    command: 'test-' + Date.now()
                };
                leader.log.push(logEntry);
                
                // 等待日志复制
                await wait(2000);
                
                // 检查日志复制情况
                const replicationSuccess = state.current.servers.every(server => 
                    server.log.length >= 1 && 
                    server.log[server.log.length - 1].term === logEntry.term
                );
                
                if (replicationSuccess) {
                    log('日志复制成功: 所有服务器都收到了日志', 'success');
                    return true;
                } else {
                    log('日志复制失败: 部分服务器未收到日志', 'error');
                    return false;
                }
            }

            // 测试场景4: 网络分区
            async function testNetworkPartition() {
                log('开始测试: 网络分区', 'info');
                
                // 等待初始Leader选举
                const initialLeader = await waitForLeader();
                if (!initialLeader) {
                    log('测试失败: 无法选出初始Leader', 'error');
                    return false;
                }
                
                // 创建网络分区
                const partitionSize = Math.floor(NUM_SERVERS / 2);
                const partition1 = state.current.servers.slice(0, partitionSize);
                const partition2 = state.current.servers.slice(partitionSize);
                
                // 更新每个分区中服务器的peers
                partition1.forEach(server => {
                    server.peers = partition1
                        .filter(s => s.id !== server.id)
                        .map(s => s.id);
                });
                
                partition2.forEach(server => {
                    server.peers = partition2
                        .filter(s => s.id !== server.id)
                        .map(s => s.id);
                });
                
                // 等待新的选举
                await wait(3000);
                
                // 检查两个分区是否都有Leader
                const leader1 = partition1.find(s => s.state === 'leader');
                const leader2 = partition2.find(s => s.state === 'leader');
                
                if (leader1 && leader2) {
                    log(`网络分区成功: 分区1 Leader=${leader1.id}, 分区2 Leader=${leader2.id}`, 'success');
                    return true;
                } else {
                    log('网络分区测试失败: 无法在两个分区中都选出Leader', 'error');
                    return false;
                }
            }

            // 运行所有测试
            async function runAllTests() {
                log('开始运行所有测试场景', 'info');
                
                const results = [];
                results.push(await testLeaderElection());
                await wait(1000);
                
                results.push(await testLeaderCrash());
                await wait(1000);
                
                results.push(await testLogReplication());
                await wait(1000);
                
                results.push(await testNetworkPartition());
                
                const successCount = results.filter(r => r).length;
                log(`测试完成: ${successCount}/${results.length} 个测试通过`, 
                    successCount === results.length ? 'success' : 'error');
                
                stopTimeDriver();
            }

            // 绑定按钮事件
            $('#run-all-tests').click(runAllTests);
            $('#test-leader-election').click(testLeaderElection);
            $('#test-leader-crash').click(testLeaderCrash);
            $('#test-log-replication').click(testLogReplication);
            $('#test-network-partition').click(testNetworkPartition);

            // 初始化
            initState();
            startTimeDriver();
        });
    </script>
</body>
</html> 